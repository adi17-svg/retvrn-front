import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:http/http.dart' as http;
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:record/record.dart' as record;
import 'package:path/path.dart' as path;
import 'package:http_parser/http_parser.dart';
import 'package:just_audio/just_audio.dart';

import '../data/bg_data.dart';
import '../main.dart';
import '../screens/task_history_screen.dart';
import '../screens/spiral_evolution_chart.dart';

class MergedReflectScreen extends StatefulWidget {
  const MergedReflectScreen({super.key});

  @override
  State<MergedReflectScreen> createState() => _MergedReflectScreenState();
}

class _MergedReflectScreenState extends State<MergedReflectScreen> {
  final _controller = TextEditingController();
  final user = FirebaseAuth.instance.currentUser;
  final firestore = FirebaseFirestore.instance;
  bool isLoading = false;
  List<Map<String, dynamic>> messages = [];
  String? lastStage;
  Map<String, dynamic>? selectedMessage;

  final record.AudioRecorder _recorder = record.AudioRecorder();
  bool _isRecording = false;

  bool _taskExpanded = true;
  Map<String, bool> completedTasks = {};

  @override
  void initState() {
    super.initState();
    _loadMessages();
    _requestPermissions();
    _loadCompletedTasks();
  }

  Future<void> _requestPermissions() async {
    await [Permission.microphone, Permission.storage].request();
  }

  Future<void> _loadMessages() async {
    final snapshot =
        await firestore
            .collection('users')
            .doc(user!.uid)
            .collection('mergedMessages')
            .orderBy('timestamp')
            .get();

    setState(() {
      messages =
          snapshot.docs
              .map((doc) => doc.data()..['id'] = doc.id)
              .cast<Map<String, dynamic>>()
              .toList();

      for (final msg in messages.reversed) {
        if (msg['type'] == 'spiral' && (msg['stage'] ?? '') != '') {
          lastStage = msg['stage'];
          break;
        }
      }
    });
  }

  Future<void> _loadCompletedTasks() async {
    final doc =
        await firestore
            .collection('users')
            .doc(user!.uid)
            .collection('taskCompletion')
            .doc('completed')
            .get();

    if (doc.exists) {
      final data = doc.data();
      if (data != null) {
        setState(() {
          completedTasks = Map<String, bool>.from(data);
        });
      }
    }
  }

  Future<void> _markTaskComplete(String stage, String dateKey) async {
    final key = '$dateKey|$stage';
    setState(() {
      completedTasks[key] = true;
    });

    await firestore
        .collection('users')
        .doc(user!.uid)
        .collection('taskCompletion')
        .doc('completed')
        .set({key: true}, SetOptions(merge: true));
  }

  Future<void> sendEntry(String entry) async {
    if (entry.trim().isEmpty) return;
    setState(() => isLoading = true);
    final url = Uri.parse("http://192.168.144.126:5000/merged");

    try {
      final response = await http.post(
        url,
        headers: {"Content-Type": "application/json"},
        body: jsonEncode({
          "text": entry,
          "last_stage": lastStage ?? "",
          "reply_to":
              selectedMessage?['question'] ??
              selectedMessage?['response'] ??
              selectedMessage?['user'] ??
              selectedMessage?['message'] ??
              "",
        }),
      );

      final now = DateTime.now();

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);

        final base = {
          'user': entry,
          'timestamp': now,
          if (selectedMessage != null)
            'reply_to':
                selectedMessage?['question'] ??
                selectedMessage?['response'] ??
                selectedMessage?['user'] ??
                selectedMessage?['message'] ??
                "",
        };

        if (data['mode'] == 'chat') {
          final msg = {
            ...base,
            'type': 'chat',
            'response': data['response'] ?? '',
          };
          await _storeMessage(msg);
        } else if (data['mode'] == 'spiral') {
          final newStage = data['stage'] ?? '';
          lastStage = newStage;

          final msg = {
            ...base,
            'type': 'spiral',
            'stage': newStage,
            'question': data['question'] ?? '',
            'evolution': data['evolution'] ?? '',
            'growth': data['growth'] ?? '',
            'task': data['task'] ?? '',
          };
          await _storeMessage(msg);
        }

        selectedMessage = null;
      } else {
        messages.add({
          'type': 'error',
          'message': 'Server error: ${response.statusCode}',
          'timestamp': now,
        });
      }
    } catch (e) {
      messages.add({
        'type': 'error',
        'message': 'Network error: ${e.toString()}',
        'timestamp': DateTime.now(),
      });
    } finally {
      setState(() {
        isLoading = false;
        _controller.clear();
      });
    }
  }

  Future<void> _storeMessage(Map<String, dynamic> msg) async {
    await firestore
        .collection('users')
        .doc(user!.uid)
        .collection('mergedMessages')
        .add(msg);
    setState(() => messages.add(msg));
  }

  Future<String> _getTempFilePath() async {
    final dir = await getTemporaryDirectory();
    return path.join(dir.path, 'journal.wav');
  }

  Future<void> _startRecording() async {
    final filePath = await _getTempFilePath();
    final hasPermission = await _recorder.hasPermission();
    if (!hasPermission) return;

    try {
      await _recorder.start(
        const record.RecordConfig(
          encoder: record.AudioEncoder.wav,
          sampleRate: 16000,
          numChannels: 1,
        ),
        path: filePath,
      );
      setState(() => _isRecording = true);
    } catch (e) {
      debugPrint("‚ùå Failed to start recording: $e");
    }
  }

  Future<void> _stopRecording() async {
    try {
      final filePath = await _recorder.stop();
      setState(() => _isRecording = false);

      if (filePath != null) {
        final file = File(filePath);
        if (await file.exists() && await file.length() > 0) {
          await _sendVoiceToBackend(file);
        }
      }
    } catch (e) {
      debugPrint("‚ùå Failed to stop recording: $e");
    }
  }

  Future<void> _sendVoiceToBackend(File file) async {
    final uri = Uri.parse("http://192.168.144.126:5000/reflect_transcription");

    final request =
        http.MultipartRequest('POST', uri)
          ..fields['last_stage'] = lastStage ?? ''
          ..fields['reply_to'] =
              selectedMessage?['question'] ??
              selectedMessage?['response'] ??
              selectedMessage?['user'] ??
              selectedMessage?['message'] ??
              ""
          ..files.add(
            await http.MultipartFile.fromPath(
              'file',
              file.path,
              contentType: MediaType('audio', 'wav'),
            ),
          );

    try {
      final response = await request.send();
      final responseBody = await response.stream.bytesToString();
      final data = json.decode(responseBody);
      final now = DateTime.now();

      if (response.statusCode == 200) {
        final msg = {
          'user': '[Voice]',
          'timestamp': now,
          'audioPath': file.path,
          'text': data['transcription'] ?? '',
          'type': data['mode'],
        };

        if (data['mode'] == 'chat') {
          msg['response'] = data['response'];
        } else {
          msg['stage'] = data['stage'];
          msg['question'] = data['question'];
          msg['growth'] = data['growth'];
          msg['evolution'] = data['evolution'];
          msg['task'] = data['task'];
          lastStage = data['stage'];
        }

        await _storeMessage(msg);
      }
    } catch (e) {
      debugPrint("‚ùå Error sending audio: $e");
    }
  }

  List<Map<String, dynamic>> getMessagesWithDateHeaders() {
    List<Map<String, dynamic>> processed = [];
    String? lastDate;

    for (final msg in messages) {
      final timestamp =
          msg['timestamp'] is Timestamp
              ? (msg['timestamp'] as Timestamp).toDate()
              : DateTime.now();
      final dateStr = DateFormat('yyyy-MM-dd').format(timestamp);

      if (lastDate != dateStr) {
        processed.add({'type': 'date-header', 'date': timestamp});
        lastDate = dateStr;
      }

      processed.add(msg);
    }

    return processed;
  }

  Widget? buildDailyTaskBanner() {
    final recentTaskMessage =
        messages
            .where((m) => m['type'] == 'spiral' && (m['task'] ?? '').isNotEmpty)
            .toList()
            .reversed
            .cast<Map<String, dynamic>>()
            .firstOrNull;

    if (recentTaskMessage == null) return null;

    final stage = recentTaskMessage['stage'];
    final dateKey = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final taskCompleted = completedTasks['$dateKey|$stage'] ?? false;

    return GestureDetector(
      onTap: () => setState(() => _taskExpanded = !_taskExpanded),
      child: Container(
        width: double.infinity,
        margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: Colors.yellow[100],
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black12,
              blurRadius: 4,
              offset: Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  "üåü Today‚Äôs Inner Task",
                  style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                ),
                Icon(_taskExpanded ? Icons.expand_less : Icons.expand_more),
              ],
            ),
            if (_taskExpanded) ...[
              const SizedBox(height: 6),
              Text(
                recentTaskMessage['task'],
                style: const TextStyle(
                  fontStyle: FontStyle.italic,
                  fontSize: 14,
                  color: Colors.black87,
                ),
              ),
              Row(
                children: [
                  Checkbox(
                    value: taskCompleted,
                    onChanged:
                        taskCompleted
                            ? null
                            : (val) => _markTaskComplete(stage, dateKey),
                  ),
                  const Text("Mark as Completed"),
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget buildChatBubble(Map<String, dynamic> msg) {
    final timestamp =
        msg['timestamp'] is Timestamp
            ? (msg['timestamp'] as Timestamp).toDate()
            : DateTime.now();

    if (msg['type'] == 'date-header') {
      return Center(
        child: Container(
          margin: const EdgeInsets.symmetric(vertical: 10),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
          decoration: BoxDecoration(
            color: Colors.grey[300],
            borderRadius: BorderRadius.circular(10),
          ),
          child: Text(
            DateFormat('EEEE, MMM d, yyyy').format(msg['date']),
            style: const TextStyle(
              fontSize: 12,
              color: Colors.black87,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      );
    }

    final List<Widget> chatWidgets = [];
    final replyText = msg['reply_to'] != null ? "‚Ü™Ô∏è ${msg['reply_to']}" : null;

    chatWidgets.add(
      GestureDetector(
        onLongPress: () => setState(() => selectedMessage = msg),
        child: Align(
          alignment: Alignment.centerRight,
          child: Container(
            margin: const EdgeInsets.symmetric(vertical: 6),
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.blue[200],
              borderRadius: BorderRadius.circular(12),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                if (replyText != null)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 4),
                    child: Text(
                      replyText,
                      style: const TextStyle(
                        fontStyle: FontStyle.italic,
                        fontSize: 12,
                        color: Colors.black87,
                      ),
                    ),
                  ),
                Text(
                  msg['user'] ?? '',
                  style: const TextStyle(color: Colors.black),
                ),
                if (msg['speaker'] != null)
                  Text(
                    msg['speaker'],
                    style: const TextStyle(
                      fontSize: 11,
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                Text(
                  DateFormat('hh:mm a').format(timestamp),
                  style: const TextStyle(fontSize: 10),
                ),
              ],
            ),
          ),
        ),
      ),
    );

    if (msg['user'] == '[Voice]' && msg['audioPath'] != null) {
      chatWidgets.add(AudioPlayerWidget(filePath: msg['audioPath']));
    }

    if (msg['type'] == 'chat') {
      chatWidgets.add(
        Align(
          alignment: Alignment.centerLeft,
          child: Container(
            margin: const EdgeInsets.symmetric(vertical: 6),
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.grey[200],
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(msg['response'] ?? ''),
          ),
        ),
      );
    } else if (msg['type'] == 'spiral') {
      chatWidgets.add(
        Align(
          alignment: Alignment.centerLeft,
          child: Container(
            margin: const EdgeInsets.symmetric(vertical: 6),
            padding: const EdgeInsets.all(14),
            decoration: BoxDecoration(
              color: Colors.orange[100],
              borderRadius: BorderRadius.circular(16),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  "üåÄ Stage: ${msg['stage'] ?? ''}",
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
                const SizedBox(height: 6),
                Text(
                  "‚ùì ${msg['question'] ?? ''}",
                  style: const TextStyle(
                    fontStyle: FontStyle.italic,
                    fontSize: 14,
                  ),
                ),
                if ((msg['growth'] ?? '').isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 8),
                    child: Text(
                      msg['growth'],
                      style: const TextStyle(
                        fontSize: 13,
                        fontStyle: FontStyle.italic,
                        color: Colors.green,
                      ),
                    ),
                  ),
                if ((msg['evolution'] ?? '').isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 8),
                    child: Text(
                      msg['evolution'],
                      style: const TextStyle(
                        color: Colors.green,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                if ((msg['task'] ?? '').isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 8),
                    child: Text(
                      "üìå Task: ${msg['task']}",
                      style: const TextStyle(color: Colors.purple),
                    ),
                  ),
              ],
            ),
          ),
        ),
      );
    }

    return Column(children: chatWidgets);
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Reflect & Chat"),
        actions: [
          IconButton(
            icon: const Icon(Icons.show_chart),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const SpiralEvolutionChartScreen(),
                ),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.history),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const TaskHistoryScreen(),
                ),
              );
            },
          ),
        ],
      ),
      body: ValueListenableBuilder<int>(
        valueListenable: selectedBgIndex,
        builder: (context, index, _) {
          final displayMessages = getMessagesWithDateHeaders();
          return Container(
            decoration: BoxDecoration(
              image: DecorationImage(
                image: AssetImage(bgList[index]),
                fit: BoxFit.cover,
              ),
            ),
            child: Column(
              children: [
                if (buildDailyTaskBanner() != null) buildDailyTaskBanner()!,
                Expanded(
                  child: ListView.builder(
                    padding: const EdgeInsets.all(12),
                    itemCount: displayMessages.length,
                    itemBuilder:
                        (context, index) =>
                            buildChatBubble(displayMessages[index]),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 10,
                  ),
                  child: Row(
                    children: [
                      Expanded(
                        child: TextField(
                          controller: _controller,
                          decoration: InputDecoration(
                            hintText: "Type your reflection...",
                            filled: true,
                            fillColor: Colors.white,
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(30),
                              borderSide: BorderSide.none,
                            ),
                            contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 12,
                            ),
                          ),
                          minLines: 1,
                          maxLines: 5,
                        ),
                      ),
                      const SizedBox(width: 8),
                      IconButton(
                        icon: Icon(
                          _isRecording ? Icons.stop_circle_outlined : Icons.mic,
                          color: _isRecording ? Colors.red : Colors.black,
                        ),
                        onPressed:
                            _isRecording ? _stopRecording : _startRecording,
                      ),
                      IconButton(
                        icon: const Icon(Icons.send),
                        onPressed:
                            isLoading
                                ? null
                                : () => sendEntry(_controller.text),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}

class AudioPlayerWidget extends StatefulWidget {
  final String filePath;
  const AudioPlayerWidget({super.key, required this.filePath});

  @override
  State<AudioPlayerWidget> createState() => _AudioPlayerWidgetState();
}

class _AudioPlayerWidgetState extends State<AudioPlayerWidget> {
  final AudioPlayer _player = AudioPlayer();
  bool _isPlaying = false;

  @override
  void dispose() {
    _player.dispose();
    super.dispose();
  }

  Future<void> _togglePlayPause() async {
    if (_isPlaying) {
      await _player.pause();
    } else {
      await _player.setFilePath(widget.filePath);
      await _player.play();
    }

    setState(() => _isPlaying = !_isPlaying);
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        IconButton(
          icon: Icon(_isPlaying ? Icons.pause : Icons.play_arrow),
          onPressed: _togglePlayPause,
        ),
        const Text("‚ñ∂Ô∏è Voice Note"),
      ],
    );
  }
}
